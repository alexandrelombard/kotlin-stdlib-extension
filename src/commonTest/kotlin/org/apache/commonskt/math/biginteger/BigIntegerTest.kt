package org.apache.commonskt.math.biginteger

import org.apache.commonskt.assert
import org.apache.commonskt.io.eprintln
import org.apache.commonskt.lang.Character
import org.apache.commonskt.lang.DoubleConsts
import org.apache.commonskt.math.BigDecimal
import org.apache.commonskt.math.BigInteger
import kotlin.experimental.and
import kotlin.experimental.or
import kotlin.math.abs
import kotlin.math.min
import kotlin.math.sqrt
import kotlin.random.Random
import kotlin.test.*

/*
 * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**
 * This is a simple test class created to ensure that the results
 * generated by BigInteger adhere to certain identities. Passing
 * this test is a strong assurance that the BigInteger operations
 * are working correctly.
 *
 * Four arguments may be specified which give the number of
 * decimal digits you desire in the four batches of test numbers.
 *
 * The tests are performed on arrays of random numbers which are
 * generated by a Random class as well as special cases which
 * throw in boundary numbers such as 0, 1, maximum sized, etc.
 *
 */

//
// Bit large number thresholds based on the int thresholds
// defined in BigInteger itself:
//
// KARATSUBA_THRESHOLD        = 80  ints = 2560 bits
// TOOM_COOK_THRESHOLD        = 240 ints = 7680 bits
// KARATSUBA_SQUARE_THRESHOLD = 128 ints = 4096 bits
// TOOM_COOK_SQUARE_THRESHOLD = 216 ints = 6912 bits
//
// SCHOENHAGE_BASE_CONVERSION_THRESHOLD = 20 ints = 640 bits
//
// BURNIKEL_ZIEGLER_THRESHOLD = 80  ints = 2560 bits
//
const val BITS_KARATSUBA = 2560
const val BITS_TOOM_COOK = 7680
const val BITS_KARATSUBA_SQUARE = 4096
const val BITS_TOOM_COOK_SQUARE = 6912
const val BITS_SCHOENHAGE_BASE = 640
const val BITS_BURNIKEL_ZIEGLER = 2560
const val BITS_BURNIKEL_ZIEGLER_OFFSET = 1280
const val ORDER_SMALL = 60
const val ORDER_MEDIUM = 100

// #bits for testing Karatsuba
const val ORDER_KARATSUBA = 2760

// #bits for testing Toom-Cook and Burnikel-Ziegler
const val ORDER_TOOM_COOK = 8000

// #bits for testing Karatsuba squaring
const val ORDER_KARATSUBA_SQUARE = 4200

// #bits for testing Toom-Cook squaring
const val ORDER_TOOM_COOK_SQUARE = 7000
const val SIZE = 1000 // numbers per batch

// Note: testing the larger ones takes too long.
private const val NUM_MERSENNES_TO_TEST = 7

// Note: this constant used for computed Carmichaels, not the array above
private const val NUM_CARMICHAELS_TO_TEST = 5

@ExperimentalUnsignedTypes
@ExperimentalStdlibApi
class BigIntegerTest {

    private val random = Random.Default
    var failure = false

    fun constructor() {
        var failCount = 0

        // --- guard condition tests for array indexing ---
        val arrayLength = 23
        val halfLength = arrayLength / 2
        val array = ByteArray(arrayLength)
        random.nextBytes(array)
        val offLen = arrayOf(
            intArrayOf(-1, arrayLength, 1),
            intArrayOf(0, arrayLength, 0),
            intArrayOf(1, arrayLength, 1),
            intArrayOf(arrayLength - 1, 1, 0),
            intArrayOf(arrayLength, 1, 1),
            intArrayOf(0, -1, 1),
            intArrayOf(halfLength, arrayLength - halfLength + 1, 1)
        )

        // two's complement
        for (ol in offLen) {
            var numExceptions = 0
            try {
                val bi = BigInteger(array, ol[0], ol[1])
            } catch (e: IndexOutOfBoundsException) {
                numExceptions++
            }
            if (numExceptions != ol[2]) {
                eprintln(
                    "IndexOutOfBoundsException did not occur for "
                            + " two's complement constructor with parameters offset "
                            + ol[0] + " and length " + ol[1]
                )
                failCount++
            }
        }

        // sign-magnitude
        for (ol in offLen) {
            var numExceptions = 0
            try {
                val bi = BigInteger(1, array, ol[0], ol[1])
            } catch (e: IndexOutOfBoundsException) {
                numExceptions++
            }
            if (numExceptions != ol[2]) {
                eprintln(
                    "IndexOutOfBoundsException did not occur for "
                            + " sign-magnitude constructor with parameters offset "
                            + ol[0] + " and length " + ol[1]
                )
                failCount++
            }
        }

        // --- tests for creation of zero-valued BigIntegers ---
        val magZeroLength = ByteArray(0)
        for (signum in -1..1) {
            val bi = BigInteger(signum, magZeroLength)
            if (bi.compareTo(BigInteger.ZERO) != 0) {
                eprintln("A: Zero length BigInteger != 0 for signum $signum")
                failCount++
            }
        }
        for (signum in -1..1) {
            val bi = BigInteger(signum, magZeroLength, 0, 0)
            if (bi.compareTo(BigInteger.ZERO) != 0) {
                eprintln("B: Zero length BigInteger != 0 for signum $signum")
                failCount++
            }
        }
        val magNonZeroLength = ByteArray(42)
        random.nextBytes(magNonZeroLength)
        for (signum in -1..1) {
            try {
                val bi = BigInteger(signum, magNonZeroLength, 0, 0)
                if (bi.compareTo(BigInteger.ZERO) != 0) {
                    eprintln("C: Zero length BigInteger != 0 for signum $signum")
                    failCount++
                }
            } catch (e: NumberFormatException) {
                // signum is 0 but magnitude is non-null
            }
        }

        // --- tests for accurate creation of non-zero BigIntegers ---
        for (i in 0 until SIZE) {
            // create reference value via a different code path from those tested
            val reference: BigInteger =
                BigInteger(2 + random.nextInt(336), 4, random)
            val refArray: ByteArray = reference.toByteArray()
            val refLen = refArray.size
            val factor: Int = random.nextInt(5)
            val objLen: Int = refArray.size + factor * random.nextInt(refArray.size) + 1
            val offset: Int = random.nextInt(objLen - refLen)
            val objArray = ByteArray(objLen)
            refArray.copyInto(objArray, offset, 0, refLen)
            val twosComp = BigInteger(objArray, offset, refLen)
            if (twosComp.compareTo(reference) != 0) {
                eprintln(
                    "Two's-complement BigInteger not equal for offset " +
                            offset + " and length " + refLen
                )
                failCount++
            }
            val isNegative: Boolean = random.nextBoolean()
            val signMag = BigInteger(if (isNegative) -1 else 1, objArray, offset, refLen)
            if (signMag.compareTo(if (isNegative) reference.negate() else reference) != 0) {
                eprintln(
                    "Sign-magnitude BigInteger not equal for offset " +
                            offset + " and length " + refLen
                )
                failCount++
            }
        }
        report("Constructor", failCount)
    }

    fun pow(order: Int) {
        var failCount1 = 0
        for (i in 0 until SIZE) {
            // Test identity x^power == x*x*x ... *x
            val power: Int = random.nextInt(6) + 2
            val x: BigInteger = fetchNumber(order)
            val y: BigInteger = x.pow(power)
            var z: BigInteger = x
            for (j in 1 until power) z = z.multiply(x)
            if (y != z) failCount1++
        }
        report("pow for $order bits", failCount1)
    }

    fun square(order: Int) {
        var failCount1 = 0
        for (i in 0 until SIZE) {
            // Test identity x^2 == x*x
            val x = fetchNumber(order)
            val xx: BigInteger = x.multiply(x)
            val x2: BigInteger = x.pow(2)
            if (x2 != xx) failCount1++
        }
        report("square for $order bits", failCount1)
    }

    private fun printErr(msg: String) {
        eprintln(msg)
    }

    private fun checkResult(
        expected: BigInteger, actual: BigInteger,
        failureMessage: String
    ): Int {
        if (expected.compareTo(actual) != 0) {
            printErr(
                failureMessage + " - expected: " + expected
                        + ", actual: " + actual
            )
            return 1
        }
        return 0
    }

    private fun squareRootSmall() {
        var failCount = 0

        // A negative value should cause an exception.
        val n: BigInteger = BigInteger.ONE.negate()
        val s: BigInteger
        try {
            s = n.sqrt()
            // If sqrt() does not throw an exception that is a failure.
            failCount++
            printErr("sqrt() of negative number did not throw an exception")
        } catch (expected: ArithmeticException) {
            // A negative value should cause an exception and is not a failure.
        }

        // A zero value should return BigInteger.ZERO.
        failCount += checkResult(
            BigInteger.ZERO, BigInteger.ZERO.sqrt(),
            "sqrt(0) != BigInteger.ZERO"
        )

        // 1 <= value < 4 should return BigInteger.ONE.
        val smalls = longArrayOf(1, 2, 3)
        for (small in smalls) {
            failCount += checkResult(
                BigInteger.ONE,
                BigInteger.valueOf(small).sqrt(), "sqrt($small) != 1"
            )
        }
        report("squareRootSmall", failCount)
    }

    fun squareRoot() {
        squareRootSmall()
        val f: (BigInteger) -> Int = { n: BigInteger ->
            var failCount = 0

            // square root of n^2 -> n
            val n2: BigInteger = n.pow(2)
            failCount += checkResult(n, n2.sqrt(), "sqrt() n^2 -> n")

            // square root of n^2 + 1 -> n
            val n2up: BigInteger = n2.add(BigInteger.ONE)
            failCount += checkResult(n, n2up.sqrt(), "sqrt() n^2 + 1 -> n")

            // square root of (n + 1)^2 - 1 -> n
            val up: BigInteger = n.add(BigInteger.ONE).pow(2).subtract(BigInteger.ONE)
            failCount += checkResult(n, up.sqrt(), "sqrt() (n + 1)^2 - 1 -> n")

            // sqrt(n)^2 <= n
            val s: BigInteger = n.sqrt()
            if (s.multiply(s).compareTo(n) > 0) {
                failCount++
                printErr("sqrt(n)^2 > n for n = $n")
            }

            // (sqrt(n) + 1)^2 > n
            if (s.add(BigInteger.ONE).pow(2).compareTo(n) <= 0) {
                failCount++
                printErr("(sqrt(n) + 1)^2 <= n for n = $n")
            }
            failCount
        }
        val sb = arrayListOf<BigInteger>()
        val maxExponent: Int = DoubleConsts.MAX_EXPONENT + 1
        for (i in 1..maxExponent) {
            val p2: BigInteger = BigInteger.ONE.shiftLeft(i)
            sb.add(p2.subtract(BigInteger.ONE))
            sb.add(p2)
            sb.add(p2.add(BigInteger.ONE))
        }
        sb.add(BigDecimal(Double.MAX_VALUE).toBigInteger())
        sb.add(BigDecimal(Double.MAX_VALUE).toBigInteger().add(BigInteger.ONE))
        report(
            "squareRoot for 2^N and 2^N - 1, 1 <= N <= Double.MAX_EXPONENT",
            sb.sumBy(f)
        )
        random.nextInt()
        val ints = (0..SIZE).map { random.nextInt(4, Int.MAX_VALUE) }
        report(
            "squareRoot for int",
            ints.map { x: Int ->
                BigInteger.valueOf(x.toLong())
            }.sumBy(f)
        )
        val longs = (0..SIZE).map { random.nextLong(Int.MAX_VALUE.toLong() + 1L, Long.MAX_VALUE) }
        report(
            "squareRoot for long",
            longs.map { x: Long ->
                BigInteger.valueOf(x)
            }.sumBy(f)
        )
        val doubles = (0..SIZE).map { random.nextDouble(Long.MAX_VALUE.toDouble() + 1.0, sqrt(Double.MAX_VALUE)) }
        report(
            "squareRoot for double",
            doubles.map { x: Double ->
                BigDecimal.valueOf(x).toBigInteger()
            }.sumBy(f)
        )
    }

    fun squareRootAndRemainder() {
        val g: (BigInteger) -> Int = { n: BigInteger ->
            var failCount = 0
            val n2: BigInteger = n.pow(2)

            // square root of n^2 -> n
            var actual: Array<BigInteger> = n2.sqrtAndRemainder()
            failCount += checkResult(n, actual[0], "sqrtAndRemainder()[0]")
            failCount += checkResult(
                BigInteger.ZERO, actual[1],
                "sqrtAndRemainder()[1]"
            )

            // square root of n^2 + 1 -> n
            val n2up: BigInteger = n2.add(BigInteger.ONE)
            actual = n2up.sqrtAndRemainder()
            failCount += checkResult(n, actual[0], "sqrtAndRemainder()[0]")
            failCount += checkResult(
                BigInteger.ONE, actual[1],
                "sqrtAndRemainder()[1]"
            )

            // square root of (n + 1)^2 - 1 -> n
            val up: BigInteger = n.add(BigInteger.ONE).pow(2).subtract(BigInteger.ONE)
            actual = up.sqrtAndRemainder()
            failCount += checkResult(n, actual[0], "sqrtAndRemainder()[0]")
            val r: BigInteger = up.subtract(n2)
            failCount += checkResult(r, actual[1], "sqrtAndRemainder()[1]")
            failCount
        }
        val bits = (0..SIZE).map { random.nextInt(3, Short.MAX_VALUE.toInt()) }
        report(
            "sqrtAndRemainder",
            bits.map { x: Int ->
                BigInteger.valueOf(x.toLong())
            }.sumBy(g)
        )
    }

    fun arithmetic(order: Int) {
        var failCount = 0
        for (i in 0 until SIZE) {
            var x: BigInteger = fetchNumber(order)
            while (x.compareTo(BigInteger.ZERO) != 1) x = fetchNumber(order)
            var y: BigInteger = fetchNumber(order / 2)
            while (x.compareTo(y) == -1) y = fetchNumber(order / 2)
            if (y == BigInteger.ZERO) y = y.add(BigInteger.ONE)

            // Test identity ((x/y))*y + x%y - x == 0
            // using separate divide() and remainder()
            var baz = x.divide(y)
            assert(baz !== null)
            if (baz !== null) {
                baz = baz.multiply(y)
                baz = baz.add(x.remainder(y))
                baz = baz.subtract(x)
                if (baz != BigInteger.ZERO) failCount++
            }
        }
        report("Arithmetic I for $order bits", failCount)
        failCount = 0
        for (i in 0..99) {
            var x: BigInteger = fetchNumber(order)
            while (x.compareTo(BigInteger.ZERO) != 1) x = fetchNumber(order)
            var y: BigInteger = fetchNumber(order / 2)
            while (x.compareTo(y) == -1) y = fetchNumber(order / 2)
            if (y == BigInteger.ZERO) y = y.add(BigInteger.ONE)

            // Test identity ((x/y))*y + x%y - x == 0
            // using divideAndRemainder()
            val baz: Array<BigInteger> = x.divideAndRemainder(y)
            baz[0] = baz[0].multiply(y)
            baz[0] = baz[0].add(baz[1])
            baz[0] = baz[0].subtract(x)
            if (baz[0] != BigInteger.ZERO) failCount++
        }
        report("Arithmetic II for $order bits", failCount)
    }

    /**
     * Sanity test for Karatsuba and 3-way Toom-Cook multiplication.
     * For each of the Karatsuba and 3-way Toom-Cook multiplication thresholds,
     * construct two factors each with a mag array one element shorter than the
     * threshold, and with the most significant bit set and the rest of the bits
     * random. Each of these numbers will therefore be below the threshold but
     * if shifted left be above the threshold. Call the numbers 'u' and 'v' and
     * define random shifts 'a' and 'b' in the range [1,32]. Then we have the
     * identity
     * <pre>
     * (u << a)*(v << b) = (u*v) << (a + b)
    </pre> *
     * For Karatsuba multiplication, the right hand expression will be evaluated
     * using the standard naive algorithm, and the left hand expression using
     * the Karatsuba algorithm. For 3-way Toom-Cook multiplication, the right
     * hand expression will be evaluated using Karatsuba multiplication, and the
     * left hand expression using 3-way Toom-Cook multiplication.
     */
    fun multiplyLarge() {
        var failCount = 0
        var base: BigInteger = BigInteger.ONE.shiftLeft(BITS_KARATSUBA - 32 - 1)
        for (i in 0 until SIZE) {
            val x = fetchNumber(BITS_KARATSUBA - 32 - 1)
            val u: BigInteger = base.add(x)
            val a: Int = 1 + random.nextInt(31)
            val w: BigInteger = u.shiftLeft(a)
            val y = fetchNumber(BITS_KARATSUBA - 32 - 1)
            val v: BigInteger = base.add(y)
            val b: Int = 1 + random.nextInt(32)
            val z: BigInteger = v.shiftLeft(b)
            val multiplyResult: BigInteger = u.multiply(v).shiftLeft(a + b)
            val karatsubaMultiplyResult: BigInteger = w.multiply(z)
            if (multiplyResult != karatsubaMultiplyResult) {
                failCount++
            }
        }
        report("multiplyLarge Karatsuba", failCount)
        failCount = 0
        base = base.shiftLeft(BITS_TOOM_COOK - BITS_KARATSUBA)
        for (i in 0 until SIZE) {
            val x = fetchNumber(BITS_TOOM_COOK - 32 - 1)
            val u: BigInteger = base.add(x)
            val u2: BigInteger = u.shiftLeft(1)
            val y = fetchNumber(BITS_TOOM_COOK - 32 - 1)
            val v: BigInteger = base.add(y)
            val v2: BigInteger = v.shiftLeft(1)
            val multiplyResult: BigInteger = u.multiply(v).shiftLeft(2)
            val toomCookMultiplyResult: BigInteger = u2.multiply(v2)
            if (multiplyResult != toomCookMultiplyResult) {
                failCount++
            }
        }
        report("multiplyLarge Toom-Cook", failCount)
    }

    /**
     * Sanity test for Karatsuba and 3-way Toom-Cook squaring.
     * This test is analogous to [AbstractMethodError.multiplyLarge]
     * with both factors being equal. The squaring methods will not be tested
     * unless the `bigInteger.multiply(bigInteger)` tests whether
     * the parameter is the same instance on which the method is being invoked
     * and calls `square()` accordingly.
     */
    fun squareLarge() {
        var failCount = 0
        var base: BigInteger =
            BigInteger.ONE.shiftLeft(BITS_KARATSUBA_SQUARE - 32 - 1)
        for (i in 0 until SIZE) {
            val x = fetchNumber(BITS_KARATSUBA_SQUARE - 32 - 1)
            val u: BigInteger = base.add(x)
            val a: Int = 1 + random.nextInt(31)
            val w: BigInteger = u.shiftLeft(a)
            val squareResult: BigInteger = u.multiply(u).shiftLeft(2 * a)
            val karatsubaSquareResult: BigInteger = w.multiply(w)
            if (squareResult != karatsubaSquareResult) {
                failCount++
            }
        }
        report("squareLarge Karatsuba", failCount)
        failCount = 0
        base = base.shiftLeft(BITS_TOOM_COOK_SQUARE - BITS_KARATSUBA_SQUARE)
        for (i in 0 until SIZE) {
            val x = fetchNumber(BITS_TOOM_COOK_SQUARE - 32 - 1)
            val u: BigInteger = base.add(x)
            val a: Int = 1 + random.nextInt(31)
            val w: BigInteger = u.shiftLeft(a)
            val squareResult: BigInteger = u.multiply(u).shiftLeft(2 * a)
            val toomCookSquareResult: BigInteger = w.multiply(w)
            if (squareResult != toomCookSquareResult) {
                failCount++
            }
        }
        report("squareLarge Toom-Cook", failCount)
    }

    /**
     * Sanity test for Burnikel-Ziegler division.  The Burnikel-Ziegler division
     * algorithm is used when each of the dividend and the divisor has at least
     * a specified number of ints in its representation.  This test is based on
     * the observation that if `w = u*pow(2,a)` and `z = v*pow(2,b)`
     * where `abs(u) > abs(v)` and `a > b && b > 0`, then if
     * `w/z = q1*z + r1` and `u/v = q2*v + r2`, then
     * `q1 = q2*pow(2,a-b)` and `r1 = r2*pow(2,b)`.  The test
     * ensures that `v` is just under the B-Z threshold, that `z` is
     * over the threshold and `w` is much larger than `z`. This
     * implies that `u/v` uses the standard division algorithm and
     * `w/z` uses the B-Z algorithm.  The results of the two algorithms
     * are then compared using the observation described in the foregoing and
     * if they are not equal a failure is logged.
     */
    fun divideLarge() {
        var failCount = 0
        val base: BigInteger =
            BigInteger.ONE.shiftLeft(BITS_BURNIKEL_ZIEGLER + BITS_BURNIKEL_ZIEGLER_OFFSET - 33)
        for (i in 0 until SIZE) {
            val addend: BigInteger = BigInteger(
                BITS_BURNIKEL_ZIEGLER + BITS_BURNIKEL_ZIEGLER_OFFSET - 34,
                random
            )
            var v: BigInteger = base.add(addend)
            var u: BigInteger = v.multiply(
                BigInteger.valueOf(
                    2 + random.nextInt(Short.MAX_VALUE - 1).toLong()
                )
            )
            if (random.nextBoolean()) {
                u = u.negate()
            }
            if (random.nextBoolean()) {
                v = v.negate()
            }
            val a: Int = BITS_BURNIKEL_ZIEGLER_OFFSET + random.nextInt(16)
            val b: Int = 1 + random.nextInt(16)
            val w: BigInteger = u.multiply(BigInteger.ONE.shiftLeft(a))
            val z: BigInteger = v.multiply(BigInteger.ONE.shiftLeft(b))
            val divideResult: Array<BigInteger> = u.divideAndRemainder(v)
            divideResult[0] = divideResult[0].multiply(BigInteger.ONE.shiftLeft(a - b))
            divideResult[1] = divideResult[1].multiply(BigInteger.ONE.shiftLeft(b))
            val bzResult: Array<BigInteger> = w.divideAndRemainder(z)
            if (divideResult[0].compareTo(bzResult[0]) != 0 ||
                divideResult[1].compareTo(bzResult[1]) != 0
            ) {
                failCount++
            }
        }
        report("divideLarge", failCount)
    }

    fun bitCount() {
        var failCount = 0
        for (i in 0 until SIZE * 10) {
            val x: Int = random.nextInt()
            val bigX: BigInteger = BigInteger.valueOf(x.toLong())
            val bit = if (x < 0) 0 else 1
            var tmp = x
            var bitCount = 0
            for (j in 0..31) {
                bitCount += if (tmp and 1 == bit) 1 else 0
                tmp = tmp shr 1
            }
            if (bigX.bitCount() != bitCount) {
                //System.err.println(x+": "+bitCount+", "+bigX.bitCount());
                failCount++
            }
        }
        report("Bit Count", failCount)
    }

    fun bitLength() {
        var failCount = 0
        for (i in 0 until SIZE * 10) {
            val x: Int = random.nextInt()
            val bigX: BigInteger = BigInteger.valueOf(x.toLong())
            val signBit = if (x < 0) -0x80000000 else 0
            var tmp = x
            var bitLength: Int
            var j: Int
            j = 0
            while (j < 32 && tmp and -0x80000000 == signBit) {
                tmp = tmp shl 1
                j++
            }
            bitLength = 32 - j
            if (bigX.bitLength() != bitLength) {
                //System.err.println(x+": "+bitLength+", "+bigX.bitLength());
                failCount++
            }
        }
        report("BitLength", failCount)
    }

    fun bitOps(order: Int) {
        var failCount1 = 0
        var failCount2 = 0
        var failCount3 = 0
        for (i in 0 until SIZE * 5) {
            val x = fetchNumber(order)
            var y: BigInteger

            // Test setBit and clearBit (and testBit)
            if (x.signum() < 0) {
                y = BigInteger.valueOf(-1)
                for (j in 0 until x.bitLength()) if (!x.testBit(j)) y = y.clearBit(j)
            } else {
                y = BigInteger.ZERO
                for (j in 0 until x.bitLength()) if (x.testBit(j)) y = y.setBit(j)
            }
            if (x != y) failCount1++

            // Test flipBit (and testBit)
            y = BigInteger.valueOf(if (x.signum() < 0) -1 else 0.toLong())
            for (j in 0 until x.bitLength()) if ((x.signum() < 0) xor x.testBit(j)) y = y.flipBit(j)
            if (x != y) failCount2++
        }
        report("clearBit/testBit for $order bits", failCount1)
        report("flipBit/testBit for $order bits", failCount2)
        for (i in 0 until SIZE * 5) {
            val x = fetchNumber(order)

            // Test getLowestSetBit()
            val k: Int = x.lowestSetBit
            if (x.signum() == 0) {
                if (k != -1) failCount3++
            } else {
                val z: BigInteger = x.and(x.negate())
                var j: Int
                j = 0
                while (j < z.bitLength() && !z.testBit(j)) {
                    j++
                }
                if (k != j) failCount3++
            }
        }
        report("getLowestSetBit for $order bits", failCount3)
    }

    fun bitwise(order: Int) {

        // Test identity x^y == x|y &~ x&y
        var failCount = 0
        for (i in 0 until SIZE) {
            val x = fetchNumber(order)
            val y = fetchNumber(order)
            val z: BigInteger = x.xor(y)
            val w: BigInteger = x.or(y).andNot(x.and(y))
            if (z != w) failCount++
        }
        report("Logic (^ | & ~) for $order bits", failCount)

        // Test identity x &~ y == ~(~x | y)
        failCount = 0
        for (i in 0 until SIZE) {
            val x = fetchNumber(order)
            val y = fetchNumber(order)
            val z: BigInteger = x.andNot(y)
            val w: BigInteger = x.not().or(y).not()
            if (z != w) failCount++
        }
        report("Logic (&~ | ~) for $order bits", failCount)
    }

    fun shift(order: Int) {
        var failCount1 = 0
        var failCount2 = 0
        var failCount3 = 0
        for (i in 0..99) {
            val x = fetchNumber(order)
            val n: Int = abs(random.nextInt() % 200)
            if (x.shiftLeft(n) != x.multiply(BigInteger.valueOf(2L).pow(n))) failCount1++
            val y: Array<BigInteger> = x.divideAndRemainder(BigInteger.valueOf(2L).pow(n))
            val z: BigInteger = if (x.signum() < 0 && y[1].signum() != 0) y[0]
                .subtract(BigInteger.ONE) else y[0]
            val b: BigInteger = x.shiftRight(n)
            if (b != z) {
                eprintln("Input is " + x.toString(2))
                eprintln("shift is $n")
                eprintln("Divided " + z.toString(2))
                eprintln("Shifted is " + b.toString(2))
                if (b.toString() == z.toString()) eprintln("Houston, we have a problem.")
                failCount2++
            }
            if (x.shiftLeft(n).shiftRight(n) != x) failCount3++
        }
        report("baz shiftLeft for $order bits", failCount1)
        report("baz shiftRight for $order bits", failCount2)
        report("baz shiftLeft/Right for $order bits", failCount3)
    }

    fun divideAndRemainder(order: Int) {
        var failCount1 = 0
        for (i in 0 until SIZE) {
            var x: BigInteger = fetchNumber(order).abs()
            while (x.compareTo(BigInteger.valueOf(3L)) != 1) x = fetchNumber(order).abs()
            val z: BigInteger? = x.divide(BigInteger.valueOf(2L))
            var y: Array<BigInteger> = x.divideAndRemainder(x)
            if (y[0] != BigInteger.ONE) {
                failCount1++
                eprintln("fail1 x :$x")
                eprintln("      y :$y")
            } else if (y[1] != BigInteger.ZERO) {
                failCount1++
                eprintln("fail2 x :$x")
                eprintln("      y :$y")
            }
            y = x.divideAndRemainder(z!!)
            if (y[0] != BigInteger.valueOf(2)) {
                failCount1++
                eprintln("fail3 x :$x")
                eprintln("      y :$y")
            }
        }
        report("divideAndRemainder for $order bits", failCount1)
    }

    fun stringConv() {
        var failCount = 0

        // Generic string conversion.
        for (i in 0..99) {
            val xBytes =
                ByteArray(abs(random.nextInt()) % 100 + 1)
            random.nextBytes(xBytes)
            val x: BigInteger = BigInteger(xBytes)
            for (radix in Character.MIN_RADIX until Character.MAX_RADIX) {
                val result: String = x.toString(radix)
                val test: BigInteger = BigInteger(result, radix)
                if (test != x) {
                    failCount++
                    eprintln("BigInteger toString: $x")
                    eprintln("Test: $test")
                    eprintln(radix.toString())
                }
            }
        }

        // String conversion straddling the Schoenhage algorithm crossover
        // threshold, and at twice and four times the threshold.
        for (k in 0..2) {
            val factor = 1 shl k
            val upper = factor * BITS_SCHOENHAGE_BASE + 33
            val lower = upper - 35
            for (bits in upper downTo lower) {
                for (i in 0..49) {
                    val x: BigInteger = BigInteger.ONE.shiftLeft(bits - 1)
                        .or(BigInteger(bits - 2, random))
                    for (radix in Character.MIN_RADIX until Character.MAX_RADIX) {
                        val result: String = x.toString(radix)
                        val test: BigInteger = BigInteger(result, radix)
                        if (test != x) {
                            failCount++
                            eprintln("BigInteger toString: $x")
                            eprintln("Test: $test")
                            eprintln(radix.toString())
                        }
                    }
                }
            }
        }
        report("String Conversion", failCount)
    }

    fun byteArrayConv(order: Int) {
        var failCount = 0
        for (i in 0 until SIZE) {
            var x = fetchNumber(order)
            while (x == BigInteger.ZERO) x = fetchNumber(order)
            val y: BigInteger = BigInteger(x.toByteArray())
            if (x != y) {
                failCount++
                eprintln("orig is $x")
                eprintln("new is $y")
            }
        }
        report("Array Conversion for $order bits", failCount)
    }

    fun modInv(order: Int) {
        var failCount = 0
        var successCount = 0
        var nonInvCount = 0
        for (i in 0 until SIZE) {
            var x = fetchNumber(order)
            while (x == BigInteger.ZERO) x = fetchNumber(order)
            var m: BigInteger = fetchNumber(order).abs()
            while (m.compareTo(BigInteger.ONE) != 1) m = fetchNumber(order).abs()
            try {
                val inv: BigInteger = x.modInverse(m)
                var prod: BigInteger = inv.multiply(x).remainder(m)
                if (prod.signum() == -1) prod = prod.add(m)
                if (prod == BigInteger.ONE) successCount++ else failCount++
            } catch (e: ArithmeticException) {
                nonInvCount++
            }
        }
        report("Modular Inverse for $order bits", failCount)
    }

    fun modExp(order1: Int, order2: Int) {
        var failCount = 0
        for (i in 0 until SIZE / 10) {
            var m: BigInteger = fetchNumber(order1).abs()
            while (m.compareTo(BigInteger.ONE) != 1) m = fetchNumber(order1).abs()
            val base = fetchNumber(order2)
            val exp: BigInteger = fetchNumber(8).abs()
            val z: BigInteger = base.modPow(exp, m)
            val w: BigInteger = base.pow(exp.toInt()).rem(m)
            if (z != w) {
                eprintln("z is $z")
                eprintln("w is $w")
                eprintln("mod is $m")
                eprintln("base is $base")
                eprintln("exp is $exp")
                failCount++
            }
        }
        report(
            "Exponentiation I for " + order1 + " and " +
                    order2 + " bits", failCount
        )
    }

    // This test is based on Fermat's theorem
    // which is not ideal because base must not be multiple of modulus
    // and modulus must be a prime or pseudoprime (Carmichael number)
    fun modExp2(order: Int) {
        var failCount = 0
        for (i in 0..9) {
            var m: BigInteger = BigInteger(100, 5, random)
            while (m.compareTo(BigInteger.ONE) != 1) m = BigInteger(100, 5, random)
            val exp: BigInteger = m.subtract(BigInteger.ONE)
            var base: BigInteger = fetchNumber(order).abs()
            while (base.compareTo(m) != -1) base = fetchNumber(order).abs()
            while (base == BigInteger.ZERO) base = fetchNumber(order).abs()
            val one: BigInteger = base.modPow(exp, m)
            if (one != BigInteger.ONE) {
                eprintln("m is $m")
                eprintln("base is $base")
                eprintln("exp is $exp")
                failCount++
            }
        }
        report("Exponentiation II for $order bits", failCount)
    }

    private val mersenne_powers = intArrayOf(
        521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937,
        21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433,
        1257787, 1398269, 2976221, 3021377, 6972593, 13466917
    )
    private val carmichaels = longArrayOf(
        561, 1105, 1729, 2465, 2821, 6601, 8911, 10585, 15841, 29341, 41041, 46657, 52633,
        62745, 63973, 75361, 101101, 115921, 126217, 162401, 172081, 188461, 252601,
        278545, 294409, 314821, 334153, 340561, 399001, 410041, 449065, 488881, 512461,
        225593397919L
    )

    private val customer_primes = arrayOf(
        "120000000000000000000000000000000019",
        "633825300114114700748351603131",
        "1461501637330902918203684832716283019651637554291",
        "779626057591079617852292862756047675913380626199",
        "857591696176672809403750477631580323575362410491",
        "910409242326391377348778281801166102059139832131",
        "929857869954035706722619989283358182285540127919",
        "961301750640481375785983980066592002055764391999",
        "1267617700951005189537696547196156120148404630231",
        "1326015641149969955786344600146607663033642528339"
    )
    private val ZERO: BigInteger = BigInteger.ZERO
    private val ONE: BigInteger = BigInteger.ONE
    private val TWO: BigInteger = BigInteger("2")
    private val SIX: BigInteger = BigInteger("6")
    private val TWELVE: BigInteger = BigInteger("12")
    private val EIGHTEEN: BigInteger = BigInteger("18")
    fun prime() {
        var p1: BigInteger
        var p2: BigInteger
        var c1: BigInteger
        var failCount = 0

        // Test consistency
        for (i in 0..9) {
            p1 = BigInteger.probablePrime(100, random)
            if (!p1.isProbablePrime(100)) {
                eprintln("Consistency " + p1.toString(16))
                failCount++
            }
        }

        // Test some known Mersenne primes (2^n)-1
        // The array holds the exponents, not the numbers being tested
        for (i in 0 until NUM_MERSENNES_TO_TEST) {
            p1 = BigInteger("2")
            p1 = p1.pow(mersenne_powers[i])
            p1 = p1.subtract(BigInteger.ONE)
            if (!p1.isProbablePrime(100)) {
                eprintln("Mersenne prime $i failed.")
                failCount++
            }
        }

        // Test some primes reported by customers as failing in the past
        for (i in customer_primes.indices) {
            p1 = BigInteger(customer_primes[i])
            if (!p1.isProbablePrime(100)) {
                eprintln("Customer prime $i failed.")
                failCount++
            }
        }

        // Test some known Carmichael numbers.
        for (i in carmichaels.indices) {
            c1 = BigInteger.valueOf(carmichaels[i])
            if (c1.isProbablePrime(100)) {
                eprintln("Carmichael $i reported as prime.")
                failCount++
            }
        }

        // Test some computed Carmichael numbers.
        // Numbers of the form (6k+1)(12k+1)(18k+1) are Carmichael numbers if
        // each of the factors is prime
        var found = 0
        var f1: BigInteger = BigInteger(40, 100, random)
        while (found < NUM_CARMICHAELS_TO_TEST) {
            var k: BigInteger? = null
            var f2: BigInteger
            var f3: BigInteger
            f1 = f1.nextProbablePrime()
            val result: Array<BigInteger> =
                f1.subtract(ONE).divideAndRemainder(SIX)
            if (result[1] == ZERO) {
                k = result[0]
                f2 = k.multiply(TWELVE).add(ONE)
                if (f2.isProbablePrime(100)) {
                    f3 = k.multiply(EIGHTEEN).add(ONE)
                    if (f3.isProbablePrime(100)) {
                        c1 = f1.multiply(f2).multiply(f3)
                        if (c1.isProbablePrime(100)) {
                            eprintln(
                                "Computed Carmichael "
                                        + c1.toString(16)
                            )
                            failCount++
                        }
                        found++
                    }
                }
            }
            f1 = f1.add(TWO)
        }

        // Test some composites that are products of 2 primes
        for (i in 0..49) {
            p1 = BigInteger.probablePrime(100, random)
            p2 = BigInteger.probablePrime(100, random)
            c1 = p1.multiply(p2)
            if (c1.isProbablePrime(100)) {
                eprintln("Composite failed " + c1.toString(16))
                failCount++
            }
        }
        for (i in 0..3) {
            p1 = BigInteger.probablePrime(600, random)
            p2 = BigInteger.probablePrime(600, random)
            c1 = p1.multiply(p2)
            if (c1.isProbablePrime(100)) {
                eprintln("Composite failed " + c1.toString(16))
                failCount++
            }
        }
        report("Prime", failCount)
    }

    private val primesTo100 = longArrayOf(
        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97
    )
    private val aPrimeSequence = longArrayOf(
        1999999003L, 1999999013L, 1999999049L, 1999999061L, 1999999081L,
        1999999087L, 1999999093L, 1999999097L, 1999999117L, 1999999121L,
        1999999151L, 1999999171L, 1999999207L, 1999999219L, 1999999271L,
        1999999321L, 1999999373L, 1999999423L, 1999999439L, 1999999499L,
        1999999553L, 1999999559L, 1999999571L, 1999999609L, 1999999613L,
        1999999621L, 1999999643L, 1999999649L, 1999999657L, 1999999747L,
        1999999763L, 1999999777L, 1999999811L, 1999999817L, 1999999829L,
        1999999853L, 1999999861L, 1999999871L, 1999999873
    )

    fun nextProbablePrime() {
        var failCount = 0
        var p1: BigInteger
        var p2: BigInteger
        var p3: BigInteger
        p3 = ZERO
        p2 = p3
        p1 = p2

        // First test nextProbablePrime on the low range starting at zero
        for (i in primesTo100.indices) {
            p1 = p1.nextProbablePrime()
            if (p1.toLong() != primesTo100[i]) {
                eprintln("low range primes failed")
                eprintln("p1 is $p1")
                eprintln("expected " + primesTo100[i])
                failCount++
            }
        }

        // Test nextProbablePrime on a relatively small, known prime sequence
        p1 = BigInteger.valueOf(aPrimeSequence[0])
        for (i in 1 until aPrimeSequence.size) {
            p1 = p1.nextProbablePrime()
            if (p1.toLong() != aPrimeSequence[i]) {
                eprintln("prime sequence failed")
                failCount++
            }
        }

        // Next, pick some large primes, use nextProbablePrime to find the
        // next one, and make sure there are no primes in between
        var i = 0
        while (i < 100) {
            p1 = BigInteger.probablePrime(50 + i, random)
            p2 = p1.add(ONE)
            p3 = p1.nextProbablePrime()
            while (p2.compareTo(p3) < 0) {
                if (p2.isProbablePrime(100)) {
                    eprintln("nextProbablePrime failed")
                    eprintln("along range " + p1.toString(16))
                    eprintln("to " + p3.toString(16))
                    failCount++
                    break
                }
                p2 = p2.add(ONE)
            }
            i += 10
        }
        report("nextProbablePrime", failCount)
    }

    /**
     * Main to interpret arguments and run several tests.
     *
     * Up to three arguments may be given to specify the SIZE of BigIntegers
     * used for call parameters 1, 2, and 3. The SIZE is interpreted as
     * the maximum number of decimal digits that the parameters will have.
     *
     */
    @Test
    fun main() {
        // Some variables for sizing test numbers in bits
        val order1 = ORDER_MEDIUM
        val order2 = ORDER_SMALL
        val order3 = ORDER_KARATSUBA
        val order4 = ORDER_TOOM_COOK
//        if (args.size > 0) order1 = (args[0].toInt() * 3.333).toInt()
//        if (args.size > 1) order2 = (args[1].toInt() * 3.333).toInt()
//        if (args.size > 2) order3 = (args[2].toInt() * 3.333).toInt()
//        if (args.size > 3) order4 = (args[3].toInt() * 3.333).toInt()
//        constructor()
//        prime()
//        nextProbablePrime()
        arithmetic(order1) // small numbers
        arithmetic(order3) // Karatsuba range
        arithmetic(order4) // Toom-Cook / Burnikel-Ziegler range
        divideAndRemainder(order1) // small numbers
        divideAndRemainder(order3) // Karatsuba range
        divideAndRemainder(order4) // Toom-Cook / Burnikel-Ziegler range
        pow(order1)
        pow(order3)
        pow(order4)
        square(ORDER_MEDIUM)
        square(ORDER_KARATSUBA_SQUARE)
        square(ORDER_TOOM_COOK_SQUARE)
        squareRoot()
        squareRootAndRemainder()
        bitCount()
        bitLength()
        bitOps(order1)
        bitwise(order1)
        shift(order1)
        byteArrayConv(order1)
        modInv(order1) // small numbers
        modInv(order3) // Karatsuba range
        modInv(order4) // Toom-Cook / Burnikel-Ziegler range
        modExp(order1, order2)
        modExp2(order1)
        stringConv()
        multiplyLarge()
        squareLarge()
        divideLarge()
        if (failure) throw RuntimeException("Failure in BigIntegerTest.")
    }

    @Test
    fun testAddSmall() {
        var arithmeticExceptions = 0
        for(i in 0..SIZE) {
            try {
                val b1 = fetchNumber(ORDER_SMALL)
                val b2 = fetchNumber(ORDER_SMALL)
                val add = b1.add(b2)
                assertEquals(b1.toLongExact() + b2.toLongExact(), add.toLongExact())
            } catch (e: ArithmeticException) {
                // Result is too large to be stored in a single long
                arithmeticExceptions++
            }
        }
        println("ArithmeticExceptions: $arithmeticExceptions (${arithmeticExceptions/SIZE.toDouble()} %)")
    }

    @Test
    fun testAddLarge() {
        var arithmeticExceptions = 0
        for(i in 0..SIZE) {
            try {
                val b1 = fetchNumber(ORDER_KARATSUBA)
                val b2 = fetchNumber(ORDER_KARATSUBA)
                val add = b1.add(b2)
                val error = abs(b1.toDouble() + b2.toDouble() - add.toDouble()) > 0.1
                b1.add(b2)
                assertFalse { error }
            } catch (e: ArithmeticException) {
                // Arithmetic exceptions should not occur here
                arithmeticExceptions++
            }
        }

        assertEquals(0, arithmeticExceptions)
    }

    @Test
    fun testSubtractSmall() {
        var arithmeticExceptions = 0
        for(i in 0..SIZE) {
            try {
                val b1 = fetchNumber(ORDER_SMALL)
                val b2 = fetchNumber(ORDER_SMALL)
                val sub = b1.subtract(b2)
                assertEquals(b1.toLongExact() - b2.toLongExact(), sub.toLongExact())
            } catch (e: ArithmeticException) {
                // Result is too large to be stored in a single long
                arithmeticExceptions++
            }
        }
        println("ArithmeticExceptions: $arithmeticExceptions (${arithmeticExceptions/SIZE.toDouble()} %)")
    }

    @Test
    fun testSubtractLarge() {
        var arithmeticExceptions = 0
        for(i in 0..SIZE) {
            try {
                val b1 = fetchNumber(ORDER_KARATSUBA)
                val b2 = fetchNumber(ORDER_KARATSUBA)
                val sub = b1.subtract(b2)
                val error = abs(b1.toDouble() + b2.toDouble() - sub.toDouble()) > 0.1
                assertFalse { error }
            } catch (e: ArithmeticException) {
                // Arithmetic exceptions should not occur here
                arithmeticExceptions++
            }
        }

        assertEquals(0, arithmeticExceptions)
    }

    @Test
    fun testMultiplySmall() {
        var arithmeticExceptions = 0
        for(i in 0..SIZE) {
            try {
                val b1 = fetchNumber(ORDER_SMALL)
                val b2 = fetchNumber(ORDER_SMALL)
                val prod = b1.multiply(b2)
                val error = abs(b1.toDouble() * b2.toDouble() - prod.toDouble()) > 0.1
                assertFalse { error }
            } catch (e: ArithmeticException) {
                // Result is too large to be stored in a single long
                arithmeticExceptions++
            }
        }
        println("ArithmeticExceptions: $arithmeticExceptions (${arithmeticExceptions/SIZE.toDouble()} %)")
    }

    @Test
    fun testDivideSmall() {
        for(i in 0..SIZE) {
            try {
                val b1 = fetchNumber(ORDER_SMALL)
                val b2 = fetchNumber(ORDER_SMALL)
                val div = b1.divide(b2)
                val error = b1.toLongExact() / b2.toLongExact() != div!!.toLongExact()
                val div2 = b1.divide(b2)
                eprintln("$b1 $b2 $div ${b1.signum} ${b2.signum} ${b1.mag.size} ${b2.mag.size}")
                assertEquals(b1.toLongExact() / b2.toLongExact(), div!!.toLongExact())
            } catch (e: ArithmeticException) {
                // Divide by zero
            }
        }
    }

    @Test
    fun testToString() {
        for(i in 0..SIZE) {
            val b = fetchNumber(ORDER_KARATSUBA)
            try {
                b.toString()
            } catch (e: Exception) {
                b.toString()
                assertFailsWith(e::class) {}
            }
        }
    }

    /*
     * Get a random or boundary-case number. This is designed to provide
     * a lot of numbers that will find failure points, such as max sized
     * numbers, empty BigIntegers, etc.
     *
     * If order is less than 2, order is changed to 2.
     */
    private fun fetchNumber(order: Int): BigInteger {
        var order = order
        val negative: Boolean = random.nextBoolean()
        val numType: Int = random.nextInt(7)
        var result: BigInteger?
        if (order < 2) order = 2
        when (numType) {
            0 -> result = BigInteger.ZERO
            1 -> result = BigInteger.ONE
            2 -> {
                val numBytes = (order + 7) / 8
                val fullBits = ByteArray(numBytes)
                var i = 0
                while (i < numBytes) {
                    fullBits[i] = 0xff.toByte()
                    i++
                }
                val excessBits = 8 * numBytes - order
                fullBits[0] = fullBits[0] and ((1 shl 8 - excessBits) - 1).toByte()
                result = BigInteger(1, fullBits)
            }
            3 -> result = BigInteger.ONE.shiftLeft(random.nextInt(order))
            4 -> {
                val `val` = ByteArray((order + 7) / 8)
                val iterations: Int = random.nextInt(order)
                var i = 0
                while (i < iterations) {
                    val bitIdx: Int = random.nextInt(order)
                    `val`[bitIdx / 8] = `val`[bitIdx / 8] or (1 shl (bitIdx % 8)).toByte()
                    i++
                }
                if(`val`[0] == 0.toByte()) `val`[0]++
                result = BigInteger(1, `val`)
            }
            5 -> {
                var localResult = ZERO
                var remaining = order
                var bit = random.nextInt(2)
                while (remaining > 0) {
                    val runLength = min(remaining, random.nextInt(order))
                    localResult = localResult.shiftLeft(runLength)
                    if (bit > 0)
                        localResult = localResult.add(ONE.shiftLeft(runLength).subtract(ONE))
                    remaining -= runLength
                    bit = 1 - bit
                }
                result = localResult
            }
            else -> result = BigInteger(order, random)
        }
        if (negative) result = result.negate()
        return result
    }

    fun report(testName: String, failCount: Int) {
        eprintln(
            testName + ": " +
                    if (failCount == 0) "Passed" else "Failed($failCount)"
        )
        if (failCount > 0) failure = true
    }
}
